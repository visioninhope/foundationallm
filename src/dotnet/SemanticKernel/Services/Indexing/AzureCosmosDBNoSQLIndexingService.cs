using FoundationaLLM.Common.Exceptions;
using FoundationaLLM.Common.Interfaces;
using FoundationaLLM.Common.Models.Configuration.CosmosDB;
using FoundationaLLM.Common.Models.Vectorization;
using FoundationaLLM.SemanticKernel.Core.Models.Configuration;
using Microsoft.Azure.Cosmos;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.SemanticKernel.Connectors.AzureCosmosDBNoSQL;
using Microsoft.SemanticKernel.Memory;
using System.Text.Json;

#pragma warning disable SKEXP0001, SKEXP0020

namespace FoundationaLLM.SemanticKernel.Core.Services.Indexing
{
    /// <summary>
    /// Provides vector embedding indexing based on the Azure Cosmos DB NoSQL API.
    /// </summary>
    public class AzureCosmosDBNoSQLIndexingService : IIndexingService
    {
        private readonly AzureCosmosDBNoSQLIndexingServiceSettings _settings;
        private readonly ILogger<AzureCosmosDBNoSQLIndexingService> _logger;
        private readonly AzureCosmosDBNoSQLMemoryStore _memoryStore;
        private readonly CosmosClient _cosmosClient;
        private readonly Database _database;

        /// <summary>
        /// Creates a new <see cref="AzureCosmosDBNoSQLIndexingService"/> instance.
        /// </summary>
        /// <param name="options">The <see cref="IOptions{TOptions}"/> providing configuration settings.</param>
        /// <param name="cosmosClient">An instance of the <see cref="CosmosClient"/> used for completing
        /// vectorization-related requests and workspace management.</param>
        /// <param name="logger">The <see cref="ILogger"/> used for logging.</param>
        public AzureCosmosDBNoSQLIndexingService(
            IOptions<AzureCosmosDBNoSQLIndexingServiceSettings> options,
            CosmosClient cosmosClient,
            ILogger<AzureCosmosDBNoSQLIndexingService> logger)
        {
            _settings = options.Value;
            _logger = logger;
            _cosmosClient = cosmosClient;
            
            // Create the database if it does not exist.
            var databaseResponse = _cosmosClient.CreateDatabaseIfNotExistsAsync(_settings.VectorDatabase).Result;
            if (!databaseResponse.StatusCode.Equals(System.Net.HttpStatusCode.OK) &&
                !databaseResponse.StatusCode.Equals(System.Net.HttpStatusCode.Created))
            {
                _logger.LogCritical("The Azure Cosmos DB vector database could not be created.");
                throw new ConfigurationValueException("The Azure Cosmos DB vector database could not be created.");
            }
            _database = databaseResponse.Database;

            _memoryStore = CreateMemoryStore();
        }

        /// <inheritdoc/>
        public async Task<List<string>> IndexEmbeddingsAsync(EmbeddedContent embeddedContent, string indexName)
        {
            if (!await _memoryStore.DoesCollectionExistAsync(indexName, default).ConfigureAwait(false))
            {
                // Use the internal method to create the collection instead of the _memoryStore method. Doing so allows us to set the throughput properties.
                await CreateCollectionAsync(indexName, default).ConfigureAwait(false);
            }

            var indexIds = new List<string>();
            var memoryRecords = embeddedContent.ContentParts.Select(cp => MemoryRecord.LocalRecord(
                cp.Id,
                cp.Content,
                "Generated by FoundationaLLM.",
                cp.Embedding.Vector,
                JsonSerializer.Serialize(embeddedContent.ContentId),
                embeddedContent.ContentId.UniqueId,
                DateTimeOffset.UtcNow)).ToList();

            await foreach (var id in _memoryStore.UpsertBatchAsync(
                indexName, memoryRecords))
            {
                indexIds.Add(id);
            }

            return indexIds;
        }

        /// <summary>
        /// Creates a new collection in the Azure Cosmos DB database for the vector embeddings.
        /// </summary>
        /// <param name="collectionName">The name of the collection to create.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns></returns>
        private async Task<bool> CreateCollectionAsync(string collectionName, CancellationToken cancellationToken = default)
        {
            _ = int.TryParse(_settings.AutoscaleMaxThroughput, out var autoscaleMaxThroughput);
            var throughputProperties = ThroughputProperties.CreateAutoscaleThroughput(autoscaleMaxThroughput);

            // Define new container properties including the vector indexing policy
            ContainerProperties properties = new(id: collectionName, partitionKeyPath: "/key")
            {
                // Define the vector embedding container policy
                VectorEmbeddingPolicy = _settings.VectorEmbeddingPolicy,
                IndexingPolicy = _settings.IndexingPolicy
            };

            // Create the container
            var response = await _database.CreateContainerIfNotExistsAsync(properties, throughputProperties, cancellationToken: cancellationToken);
            return response.StatusCode.Equals(System.Net.HttpStatusCode.OK) ||
                response.StatusCode.Equals(System.Net.HttpStatusCode.Created);
        }

        private void ValidateSettings(string connectionString, string? databaseName)
        {
            if (string.IsNullOrWhiteSpace(connectionString))
            {
                _logger.LogCritical("The Azure Cosmos DB connection string is invalid.");
                throw new ConfigurationValueException("The Azure Cosmos DB connection string is invalid.");
            }

            if (string.IsNullOrWhiteSpace(databaseName))
            {
                _logger.LogCritical("The Azure Cosmos DB vector database name is invalid.");
                throw new ConfigurationValueException("The Azure Cosmos DB vector database name is invalid.");
            }
        }

        /// <summary>
        /// Creates an <see cref="AzureCosmosDBNoSQLMemoryStore"/> instance using the injected
        /// <see cref="CosmosClient"/> and <see cref="CosmosDbSettings"/>.
        /// </summary>
        /// <returns></returns>
        private AzureCosmosDBNoSQLMemoryStore CreateMemoryStore()
        {
            ValidateSettings(_settings.ConnectionString, _settings.VectorDatabase);
            return new AzureCosmosDBNoSQLMemoryStore(
                _cosmosClient,
                _settings.VectorDatabase!,
                _settings.VectorEmbeddingPolicy,
                _settings.IndexingPolicy
            );
        }
    }
}
